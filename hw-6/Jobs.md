# Kubernetes: Jobs

---

В Kubernetes `Job` — это ресурс, который позволяет запускать однократные или краткосрочные задачи, гарантирующие выполнение одного или нескольких подов до завершения. В отличие от деплоя (Deployment) или StatefulSet, где поды запускаются в долгосрочном режиме, `Job` предназначен для выполнения задач, которые завершаются, например, обработка данных, пакетная обработка, периодические задания и т.д.

### Зачем нужен Job в Kubernetes?

`Job` необходим в следующих случаях:
- **Однократные задачи**: выполнение разовой задачи, которая должна завершиться успешно.
- **Задачи с гарантией завершения**: при аварийной остановке пода `Job` автоматически перезапустит его, чтобы гарантировать завершение работы.
- **Параллельные задачи**: `Job` позволяет запускать несколько параллельных подов для ускорения выполнения задач.
- **Генерация отчётов, резервное копирование и обработка данных**: такие задачи часто являются краткосрочными и могут запускаться с помощью `Job`.

### Виды Job

В Kubernetes существует три основных режима работы `Job`:

1. **Обычная (однократная) Job** — создаёт один под и запускает его до завершения.
2. **Параллельная Job с фиксированным числом подов** — запускает определённое количество подов одновременно.
3. **Параллельная Job с числом подов, пока не будет достигнуто требуемое количество успешных выполнений** — полезна для заданий, в которых некоторые поды могут завершиться неудачно.

### Как создавать Job в Kubernetes

`Job` создается с помощью YAML-манифеста, где описывается желаемое поведение задачи, количество подов и параметры их работы.

Пример простой `Job`:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: example-job
spec:
  template:
    metadata:
      name: example-job-pod
    spec:
      containers:
      - name: example-container
        image: busybox
        command: ["echo", "Hello, Kubernetes Job!"]
      restartPolicy: Never
```

#### Разбор:
- **apiVersion: batch/v1** — версия API, где `batch/v1` используется для создания `Job`.
- **kind: Job** — указывает, что создается ресурс типа `Job`.
- **spec.template** — шаблон пода, который будет создан `Job`.
- **containers** — описание контейнера, который будет запущен. В данном примере используется образ `busybox`, и выполняется простая команда `echo`.
- **restartPolicy: Never** — указывает, что под не будет перезапускаться, если он завершится (что нужно для краткосрочных задач).

### Параллельные Job

Параллельная Job позволяет запускать несколько подов одновременно. Параллельные задачи полезны, когда выполнение работы можно разделить на несколько параллельно исполняемых частей.

Пример параллельной `Job`, запускающей три пода параллельно:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: parallel-job
spec:
  parallelism: 3
  completions: 3
  template:
    metadata:
      name: parallel-job-pod
    spec:
      containers:
      - name: parallel-container
        image: busybox
        command: ["echo", "Parallel Job"]
      restartPolicy: Never
```

#### Разбор:
- **parallelism** — указывает количество подов, которые должны запускаться одновременно. В данном случае, три пода будут запущены параллельно.
- **completions** — указывает общее количество успешных выполнений. Здесь установлено 3, то есть `Job` будет завершена, когда три пода выполнят свою задачу.

### Job с `backoffLimit`

`backoffLimit` позволяет задать максимальное количество повторных запусков пода в случае неудачного выполнения. Если под не может успешно завершиться за указанное число попыток, `Job` будет считаться неудачной.

Пример `Job` с `backoffLimit`:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: retry-job
spec:
  backoffLimit: 4
  template:
    metadata:
      name: retry-job-pod
    spec:
      containers:
      - name: retry-container
        image: busybox
        command: ["false"]
      restartPolicy: Never
```

#### Разбор:
- **backoffLimit** — значение 4 указывает, что Kubernetes попытается перезапустить под до 4 раз, если он завершится ошибкой.

### CronJob

`CronJob` — это разновидность `Job`, которая позволяет запускать задачи по расписанию, аналогично cron-заданиям в Linux. `CronJob` полезен для регулярного выполнения заданий, таких как резервное копирование данных, отчеты, очистка данных и т.д.

Пример `CronJob`, который запускается каждые 5 минут:
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cron-example
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: cron-container
            image: busybox
            command: ["echo", "Scheduled CronJob"]
          restartPolicy: Never
```

#### Разбор:
- **schedule** — указывает расписание в формате cron. Здесь `*/5 * * * *` означает выполнение каждые 5 минут.
- **jobTemplate** — шаблон `Job`, который будет создаваться при каждом запуске по расписанию.

### Как управлять Job в Kubernetes

Чтобы управлять `Job` в Kubernetes, можно использовать стандартные команды `kubectl`:
- **Создать `Job`**:
  ```bash
  kubectl apply -f job.yaml
  ```
- **Просмотреть статус `Job`**:
  ```bash
  kubectl get jobs
  ```
- **Получить логи `Job`**:
  ```bash
  kubectl logs job/example-job
  ```
- **Удалить `Job`**:
  ```bash
  kubectl delete job example-job
  ```
  
`Job` в Kubernetes — это удобный способ запуска и контроля за краткосрочными задачами, позволяющий эффективно выполнять однократные и периодические задачи, с возможностью настройки параллельного выполнения и перезапуска при ошибках.

## CronJob
`CronJob` в Kubernetes — это тип ресурса, который позволяет запускать `Job` по расписанию. Это аналог cron-заданий в Linux, что делает `CronJob` полезным для автоматизированных задач, которые должны выполняться регулярно, например, резервное копирование данных, очистка временных файлов, генерация отчетов или другие задачи, требующие периодического выполнения.

### Зачем нужен CronJob в Kubernetes?

`CronJob` упрощает автоматизацию периодических задач, предоставляя возможности для:
- **Автоматизированных резервных копий**: регулярное копирование данных в безопасное хранилище.
- **Очистки данных**: регулярное удаление старых логов или данных для оптимизации дискового пространства.
- **Генерации отчетов и анализа данных**: сбор статистики или данных для аналитики.
- **Обновлений и синхронизаций**: выполнение задач, требующих периодических проверок или синхронизаций.

### Основные параметры CronJob и отличие от обычной Job

В отличие от обычного `Job`, `CronJob` добавляет параметры, связанные с расписанием и количеством задач, которые могут выполняться одновременно.

#### Основные параметры CronJob:

1. **schedule** — формат cron-расписания, определяющий время запуска задания. Например:
   - `"*/5 * * * *"` — каждые 5 минут.
   - `"0 0 * * *"` — каждый день в полночь.
   - `"0 0 * * 0"` — каждое воскресенье в полночь.

2. **jobTemplate** — шаблон задания `Job`, который будет создаваться при каждом запуске по расписанию. Внутри него можно указать параметры и контейнеры, аналогично обычному `Job`.

3. **startingDeadlineSeconds** — максимальное время (в секундах), в течение которого `CronJob` может быть начат после пропущенного запуска. Это полезно, если нужно восстановить пропущенные задания, например, при проблемах в кластере.

4. **concurrencyPolicy** — политика параллельного выполнения заданий. Определяет поведение при запуске следующего задания, когда предыдущее еще не завершилось:
   - `Allow` (по умолчанию) — позволяет запускать несколько заданий параллельно.
   - `Forbid` — запрещает запуск нового задания, если предыдущее еще выполняется.
   - `Replace` — прерывает текущее задание и запускает новое.

5. **successfulJobsHistoryLimit** и **failedJobsHistoryLimit** — указывают, сколько успешных и неуспешных завершённых заданий нужно сохранять. Полезно для предотвращения накопления ненужных данных.

6. **suspend** — если значение `true`, `CronJob` временно приостанавливается и не запускается по расписанию. Может использоваться для временной остановки задания без его удаления.

### Как создать CronJob в Kubernetes

`CronJob` создаётся с помощью YAML-манифеста, где указываются расписание, шаблон `Job` и параметры выполнения.

Пример простого `CronJob`, который запускается каждые 5 минут и выводит сообщение:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: simple-cron-job
spec:
  schedule: "*/5 * * * *"  # Запускается каждые 5 минут
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: cron-container
            image: busybox
            command: ["echo", "Hello from Kubernetes CronJob!"]
          restartPolicy: OnFailure
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
```

### Разбор параметров примера:

- **apiVersion: batch/v1** и **kind: CronJob** — определяют тип ресурса.
- **metadata.name** — задаёт имя `CronJob`, уникальное в пределах пространства имен.
- **spec.schedule** — указывает расписание в формате cron (`*/5 * * * *`).
- **jobTemplate** — определяет, какой `Job` будет создаваться. Здесь используется контейнер `busybox`, который выполняет команду `echo`.
- **restartPolicy: OnFailure** — указывает, что под будет перезапущен, если завершится с ошибкой.
- **successfulJobsHistoryLimit** — сохраняет только 3 последних успешных задания.
- **failedJobsHistoryLimit** — сохраняет только 1 неуспешное задание.

### Параметры CronJob для контроля выполнения

Некоторые дополнительные параметры позволяют гибко настраивать выполнение `CronJob` в зависимости от особенностей задачи и требований к кластеру:

- **concurrencyPolicy**:
  ```yaml
  concurrencyPolicy: Forbid
  ```
  Позволяет избежать накопления задач, когда предыдущее задание еще не завершилось. Полезно, когда повторный запуск предыдущей задачи нежелателен.

- **startingDeadlineSeconds**:
  ```yaml
  startingDeadlineSeconds: 200
  ```
  Этот параметр указывает максимальное количество секунд, в течение которого `CronJob` может быть начат, если он пропустил запланированный запуск. Полезно при кратковременных неполадках в кластере.

- **suspend**:
  ```yaml
  suspend: true
  ```
  Останавливает выполнение `CronJob`, при этом задание и его конфигурация сохраняются. Это временная мера, при которой задание не будет выполняться до изменения параметра на `false`.

### Пример CronJob с несколькими параметрами

Представим `CronJob`, который запускается ежедневно в полночь, выполняет резервное копирование и ограничен количеством историй выполнений и временем запуска.

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-cron-job
spec:
  schedule: "0 0 * * *"  # Запуск ежедневно в полночь
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup-container
            image: alpine
            command: ["/bin/sh", "-c", "echo Performing backup; sleep 10"]
          restartPolicy: OnFailure
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 2
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 300
```

#### Разбор параметров:

- **schedule: "0 0 * * *"** — запуск в полночь.
- **jobTemplate.spec.template.spec** — в контейнере выполняется команда резервного копирования с задержкой в 10 секунд.
- **successfulJobsHistoryLimit и failedJobsHistoryLimit** — сохраняют историю успешных и неуспешных заданий, чтобы предотвратить переполнение истории.
- **concurrencyPolicy: Forbid** — предотвращает запуск нового задания, если предыдущее ещё не завершилось.
- **startingDeadlineSeconds: 300** — если задание не успело выполниться в течение 5 минут после запланированного времени, оно будет пропущено.

### Управление CronJob в Kubernetes

Для управления `CronJob` можно использовать команды `kubectl`:

- **Создание CronJob**:
  ```bash
  kubectl apply -f cronjob.yaml
  ```
- **Просмотр всех CronJob**:
  ```bash
  kubectl get cronjob
  ```
- **Получение статуса CronJob**:
  ```bash
  kubectl describe cronjob backup-cron-job
  ```
- **Удаление CronJob**:
  ```bash
  kubectl delete cronjob backup-cron-job
  ```

`CronJob` в Kubernetes предоставляет гибкие возможности для запуска задач по расписанию, с возможностью настройки количества историй выполнений, обработки ошибок и управления параллельностью. Это делает его удобным инструментом для автоматизации процессов и планирования периодических задач в рамках кластера.